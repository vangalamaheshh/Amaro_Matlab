function [l,h]=bsub(l,outargs,fstr,inargs,queue,rusage)
% l=lsf;
% [x1,x2]=l.bsub('sort',{x});
% bsub(l,{'x1','x2'},'sort',{x}); % [x1,x2]=sort(x);

if length(find(l.jobs>0))>=maxjobs(l)
  wait_no_read(l,find(l.jobs>0),maxjobs(l)-1);
end

h=length(l.jobs)+1;

basename=get_basename(l,h);

if exist([ l.lsf_path basename '_code.m'],'file')
  l.jobs(h)=10000+h;
else
  %%%%%%%%%%%%  save inargs
  if (nargin > 3) & ~isempty(inargs)
    save([l.lsf_path basename '_in.mat'],'inargs');
  else
    inargs={};
  end
  
  %%%%%%%%%%%%  generate code
  f=fopen([l.lsf_path basename '_code.m'],'w');
  fprintf(f,['function ' basename '_code' newline]);
  fprintf(f,['%% THIS CODE WAS GENERATED BY BSUB METHOD OF THE LSF CLASS' ...
             newline]);
  fprintf(f,['[tmp,lsfjob.host]=unix(''hostname'');' newline]);
  fprintf(f,['lsfjob.path=path; disp(lsfjob.path);' newline]);
  fprintf(f,['lsfjob.start.time=clock;' newline]);
  fprintf(f,['lsfjob.start.randseed=sum(100*clock)+997*' num2str(h) ';' newline]);
  fprintf(f,['rand(''state'',lsfjob.start.randseed);' newline]);
  fprintf(f,['lsfjob.start.cputime=cputime;' newline]);
  fprintf(f,['set_verbose_level(40);' newline]);
  fprintf(f,['disp(''Starting function'')' newline]);  
  fprintf(f,['tic;' newline]);

  if ~isempty(inargs)
    fprintf(f,['load ' basename '_in.mat;' newline]);
  end
  if length(outargs)>0
    fprintf(f,'[');
    for i=1:length(outargs)
      fprintf(f,[ outargs{i} ' ']);
    end
    fprintf(f,']=');
  end
  fprintf(f,fstr);
  if ~isempty(inargs)
    fprintf(f,'(');
    for i=1:(length(inargs)-1)
      fprintf(f,['inargs{' num2str(i) '},']);
    end
    fprintf(f,['inargs{' num2str(length(inargs)) '})']);
  end

  fprintf(f,[';' newline]);

  fprintf(f,['lsfjob.end.time=clock;' newline]);
  fprintf(f,['lsfjob.end.cputime=cputime;' newline]);
  fprintf(f,['lsfjob.end.toc=toc;' newline]);
  fprintf(f,['disp(''Ended function'')' newline]);  

  fprintf(f,['save(''' basename '_out.mat'',']);
  for i=1:(length(outargs))
    fprintf(f,[ '''' outargs{i} ''',']);
  end
  fprintf(f,['''lsfjob'');' newline]);
  fprintf(f,['save(''' basename '_finished.txt'',''tmp'',''-ASCII'');' ...
             newline]);  
  fclose(f);
  verbose(['Wrote ' l.lsf_path basename '_code.m']);

  if (l.use_compiler)
    curdir=cd;
    cd(l.lsf_path);
    verbose('trying to compile');
    for i=1:10
      dd=dir([basename '_code']);
      if isempty(dd) % exist([basename '_code'],'file')
        try
          verbose(['compiling ' basename '_code.m' ' - test ' num2str(i)]);
          mcc('-v','-m','-R','-nojvm',[basename '_code.m']);
        catch
          verbose(['failed ' num2str(i)]);
        end
      else
        break
      end
    end
    cd(curdir);
  end
  %%%%%%%%% BSUB: RUN MATLAB
  if (l.use_compiler)
    [s,w]=unix(['source ~/.my.cshrc ; cd ' l.lsf_path '; bsub -r -o ' basename '_stdout.txt -e ' basename '_stderr.txt ' ...
                './' basename '_code']);  
  else   
%%%%     bsub -R 'rusage[matlab=1:duration=1]' some_matlab.sh
%    [s,w]=unix(['cd ' l.lsf_path '; bsub -r -R ''rusage[matlab=1;duration=1]'' -o ' basename '_stdout.txt -e ' ...
%                basename '_stderr.txt ' 'matlab -nodisplay -r '''
%                basename '_code; exit;''']);
    jobname=regexp(basename,'_(.*)_','tokens');
    jobname=jobname{1}{1};

    matlab_bin='/broad/tools/apps/matlab2009a/bin/matlab';
    if exist('rusage','var') || isempty(rusage)
      rusage_st=['-R "rusage[' rusage ']" '];
    else
      rusage_st=[];
    end 
    if exist('queue','var') && ~isempty(queue)
      queue_st=['-q ' queue ' '];
    else
      queue_st=[];
    end

    f=fopen([l.lsf_path basename '_runme.bat'],'w');
    fprintf(f,['#!/usr/bin/tcsh' newline]);
    fprintf(f,['echo "================================================================"' newline]);
    fprintf(f,['uname -a' newline]);
    fprintf(f,['use matlab' newline]);
    fprintf(f,['cd ' replace_space_for_unix(l.lsf_path) newline]);
    fprintf(f,[matlab_bin ' -nodisplay -r ''' basename '_code; exit;''']);
    fprintf(f,newline);
    fclose(f);
    unix(['chmod u+x ' l.lsf_path basename '_runme.bat']);
    
%    run_cmd=['uname -a; use matlab; ' ...
%             'cd ' replace_space_for_unix(l.lsf_path) '; ' ...
%             'bsub ' rusage_st queue_st ' -J ' jobname ' -r -o ' basename '_stdout.txt -e ' basename '_stderr.txt ' ...
%             matlab_bin ' -nodisplay -r ''' basename '_code; exit;'''];
    run_cmd=['cd ' replace_space_for_unix(l.lsf_path) '; ' ...
             'bsub ' rusage_st queue_st ' -J ' jobname ' -r -o ' basename '_stdout.txt -e ' basename '_stderr.txt ' ...
             l.lsf_path basename '_runme.bat'];
    
    verbose(run_cmd);
    [s,w]=unix(run_cmd);
  end
  verbose(['got:' w]);
  pos1=find(w=='<');
  pos2=find(w=='>');
  if ~isempty(pos1) & ~isempty(pos2) & pos2(1)>pos1(1)
    l.jobs(h)=str2num(w((pos1(1)+1):(pos2(1)-1)));
  else
    l.jobs(h)=-1;
  end
end
% write mfile that loads workspace, executes the function, and
% saves the results (only the results of the function)
% saves file of end

% wait will poll for the end of processes (the ones waiting for)
% and if any one finishes it will load the results and update the
% table and the jobs info.
% when all processes waited for are finished then it returns.



