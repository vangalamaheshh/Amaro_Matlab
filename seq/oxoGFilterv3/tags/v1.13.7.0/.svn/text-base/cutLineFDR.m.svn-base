function [X] = cutLineFDR(M, fdrThresh, PoxoG, fQ)
%  TODO: Update the documentation
% [X] = cutLineFDR(R_A, R_nA, fdrThresh)
%
% R_A are the mutations with an artifact signature. nx5 matrix
% R_nA are mutations without an artifact signature. nx5 matrix
% fdrThresh is the desired proportion of missed detects.  I.e.
%   artifact mutations that are identified as real mutations.  Scalar.
% PoxoG is the believed binomial p for an OxoG mutation.  Scalar.
% fQ is a correction factor (0-1) based on picard oxoQ value.  Scalar.
%
% "artifact signature" means C>A or G>T.  "artifact signature" is
%   synonymous with "artifact mode".
%
% Each mutation in R_A, or R_nA, is a row :
%
%   [foxog alt_read_count ref_read_count f1r2 f2r1]
%
% Note: This method assumes a single sample (or group of samples to be treated as
%   a single sample)
%
% Returns a struct (X) with the following fields:
%   X.NALT= alternate allele count of all mutations, regardless of artifact
%       mode.  Vector.
%   X.NART= OxoG config alternate allele count.  Vector.
%   X.iART= C>A, G>T SNPS  = 0 or 1 for false, true, respectively.  Vector
%   X.pox = probability that the mutation is from its foxog or below
%   (i.e. cumulative distribution).  Vector.
%   X.qox = Q score generated by the FDR for each mutations.  Vector.
%   X.cut = Mutations that are not likely to be real mutations with the 
%      given fdrThresh.
%
% See also ISARTIFACTSIGNATURE,CALC_FDR_VALUE
%
if (nargin < 2) || isempty(fdrThresh)
    fdrThresh = .01;
end
if (nargin < 3) || isempty(PoxoG)
    PoxoG = .96;
end
if (nargin < 4) || isempty(fQ)
    fQ = 1;
end

%% Gaddy's simple FDR/B&H method
% X is a MAF structure with many samples,
% Z is a structure of sample summary #'s (eg. Noxo, Nmut)
% X.NALT= alternate allele count of all mutations, regardless of artifact
% mode (ac)
% X.NART= OxoG config alternate allele count (foxog * ac)
% X.iART= C>A, G>T SNPS  = 0 or 1 for false, true, respectively.  I.e. are
%   the mutations in artifact mode.

X.NALT = M.alt_read_count;
X.iART = M.isArtifactMode;
X.NART = round(M.foxog .* M.alt_read_count);
X.pox=NaN*X.NALT;
X.qox=NaN*X.NALT;
X.cut=NaN*X.NALT;
X.pox=binocdf(X.NART,X.NALT,PoxoG);
X.pox(X.iART==0) = 0;
% Bejamini-Hockberg fdr estimate from X.pox p-values
X.qox=calc_fdr_value(X.pox);
X.cut=X.qox > fdrThresh;

% correct for noise floor based on oxoQ estimate 
if (fQ<1)
    % number of expected cut
    Ncut=round(sum(X.cut)*fQ);
    [q i]=sort(X.pox,'descend');
    NTOT=length(X.pox);
    rank(i,1)=(1:NTOT)';
    % refine cut selection
    X.cut=X.cut&(rank<=Ncut);
    if sum(X.cut)>0
        % min pox of cut event
        poxmin=min(X.pox(X.cut));
        % any pox >= poxmin is cut 
        X.cut=X.pox>=poxmin;
    end
end
       
