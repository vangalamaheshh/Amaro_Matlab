function context2(P)
% context2.m
%
% Generates nucleotide sequence context report by gene x sample
% from *.idx and *.dat files generated by Perl preprocessing script "pp"
%
% Procedure:
%     for each gene x patient
%         for each target
%             1. read the genomic sequence corresponding to that target
%             2. read the sequencing coverage for that patient
%             3. if target is transcribed from (-) strand, then
%                reverse-complement the sequence and reverse the coverage.
%             4. now count the number of bases in each category
%             5. report them in a table
%
% Base categories:
% (all with respect to the transcribed strand)
%     1. A
%     2. T
%     3. C in CpG
%     4. C in TpC but not TpCpG
%     5. other C
%     6. G in CpG
%     7. G in GpA but not CpGpA
%     8. other G
%
% Notes:
%     1. Some "ConsReg" genes have strand indicated as "."
%        These are treated as "+'
%     2. Totals of categories 3 and 6 need not agree,
%        due to the potential for coverage of only
%        one of the two bases in the dinucleotide.
%
% Mike Lawrence 2008/04/08
%
% Modified 2008-05-02
% 1. work with idx + dat files in different directories
%
% Modified 2008-10-29
% 1. Converted to callable function
%

if ~exist('P','var'), P=[]; end
P=impose_default_value(P,'project',[]);
P=impose_default_value(P,'targfile','/xchip/tcga/gbm/analysis/lawrence/cov/condensed_targets_2bp_with_strand.txt');
P=impose_default_value(P,'patients_to_use_file',[]);
P=impose_default_value(P,'build','hg18');
P=impose_default_value(P,'infiles',{});
P=impose_default_value(P,'outfile',[]);
P=impose_default_value(P,'use_work_splitting',false);
P=impose_default_value(P,'numparts',[]);
P=impose_default_value(P,'partnum',[]);

if isempty(P.project), error('Must supply P.project'); end
if isempty(P.infiles), error('Must supply P.infiles'); end
if isempty(P.outfile), error('Must supply P.outfile'); end
if isempty(P.patients_to_use_file), error('Must supply P.patients_to_use_file'); end

if P.use_work_splitting
  if isempty(P.numparts), error('Must supply P.numparts'); end
  if isempty(P.partnum), error('Must supply P.partnum'); end
  if P.partnum < 1 || P.partnum > P.numparts, error('Waaaaah!'); end
else
  P.numparts = 1;
  P.partnum = 1;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  LOAD TARGET LIST
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ~exist('target', 'var')
  fprintf('Reading target list\n');
  table = read_table(P.targfile, '%s%s%f%f%s', char(9), 1, 'Whitespace', '\b\r');
  target.gene = table.dat{1};
  target.chr = table.dat{2};
  target.start = table.dat{3};
  target.end = table.dat{4};
  target.strand = table.dat{5};
  ntarg = length(target.gene);
  clear table;

  % convert chromsome identifiers
  target.chr = convert_chr(target.chr);

  % convert genes to gene numbers
  [genes gi target.gno] = unique(target.gene);
  ngenes = length(genes);
  target = rmfield(target, 'gene');
  clear gi;
end % if ~exist('target','var')


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  LOAD INDEX FILES
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ~exist('region', 'var')
  fprintf('Reading index files.. ');
  region.fno = [];
  region.fpos = [];
  region.pat = {};
  region.tum = {};
  region.chr = {};
  region.start = [];
  region.end = [];
  for fno=1:length(P.infiles)
    fprintf(' file%d', fno);
    fname = [P.infiles{fno} '.idx'];
    table = read_table(fname, '%s%s%s%d%d%d', char(9), 1, 'Whitespace', '\b\r');
    region.pat = [ region.pat; table.dat{1} ];
    region.tum = [ region.tum; table.dat{2} ];
    region.chr = [ region.chr; table.dat{3} ];
    region.start = [ region.start; table.dat{4} ];
    region.end = [ region.end; table.dat{5} ];
    region.fpos = [ region.fpos; table.dat{6} ];
    region.fno = [ region.fno; repmat(fno,length(table.dat{1}),1) ];
  end
  clear table;
  nreg = length(region.fno);
  fprintf('\n');

  fprintf('Converting chromosome identifiers\n');
  region.chr = convert_chr(region.chr);

  fprintf('Analyzing sample identifiers\n');
  [patients pi region.pno] = unique(region.pat);
  npatients = length(patients);
  region = rmfield(region, 'pat');
  clear pi;
  [tum ti tj] = unique(region.tum);
  is_tumor = strcmp(tum, '01');          % 01=tumor, 10=normal, 20=normal(?)
  region.is_tumor = is_tumor(tj);
  region = rmfield(region, 'tum');
  clear tum ti tj
end % if ~exist(region)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  MATCH COVERAGE REPORT TO REGIONS
%  (if desired)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if(0)
  fprintf('Matching coverage\n');
  for chr = 1:24
     ctarg = find(target.chr == chr);
     creg = find(region.chr == chr);   
     [urs ursi ursj] = unique(region.start(creg));
     temp = region.end(creg);
     ure = temp(ursi);
     fprintf('chromosome %d --> %d unique region_starts\n', chr, length(urs));
     for r=1:length(urs)
       t = ctarg(find(ure(r) >= target.start(ctarg) & urs(r) <= target.end(ctarg)));
       if isempty(t)
          fprintf('UNMATCHED,,chr%d,%d,%d\n', chr,urs(r),ure(r));
       end
       if length(t)>1
          genes(target.gno(t))
       end
    end
  end
end % if(0)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  LOAD DAT FILES
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ~exist('datfile', 'var')
  fprintf('Reading datfiles... ');
  for fno=1:length(P.infiles)
    fprintf(' file%d', fno);
    filespec = [P.infiles{fno} '.dat'];
    if ~exist(filespec, 'file'), error(['Could not open ' filespec]); end
    f = fopen(filespec);
    datfile{fno} = fread(f, 'uint8=>char') - 48;    % convert '1' to 1
    fclose(f);
  end
  fprintf('\n');
end



% LOAD LIST OF PATIENTS TO PROCESS

if strcmp(P.project,'TCGA')
  tab = tab2struct(P.patients_to_use_file);
  patients_to_process = tab.name;
else
  patients_to_process = patients;
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  GENERATE AGGREGATED COVERAGE REPORT
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

category_name = { 'A','T','C in CpG','C in TpC','other C','G in CpG','G in GpA','other G','N?'};

if P.use_work_splitting
  P.outfile = sprintf('%s_%02d', P.outfile, P.partnum);
%  P.outfile = [P.outfile '_' num2str(partnum)];
end

fout = fopen(P.outfile, 'wt');

if P.partnum==1                 % print header if this is the first part of the report
  fprintf(fout, 'patient\tgene');
  for i=1:length(category_name)-1
       fprintf(fout, '\t%s', category_name{i});
  end
  fprintf(fout, '\n');
end

% compute this instance's share of work

if P.numparts>1
  [firstpatient,lastpatient]=calculate_work_split(P.partnum,P.numparts,npatients);
else
  firstpatient = 1;
  lastpatient = npatients;
end

for pno = firstpatient:lastpatient         % for each patient

  if ~ismember(patients{pno},patients_to_process), continue; end

  fprintf('patient %d of (%d to %d) of %d\n', pno, firstpatient, lastpatient, npatients);
  pat_regions = find(region.pno==pno);    % find all regions pertaining to that patient

  tic
  for gno = 1:ngenes          % for each gene

    if ~mod(gno,100)
        toc
        fprintf('   gene %d of %d\n', gno, ngenes);
        tic
    end

    gene_targets = find(target.gno == gno);
    gene_chr = target.chr(gene_targets(1));
    chr_regions = find(region.chr==gene_chr);
    pat_chr_regions = intersect(chr_regions,pat_regions);

    cov_by_category = zeros(9,1);   % zero-out coverage counter for this gene

    any_regions_matched = false;    % for deciding at end of analysis
                                    % whether to include this gene in report

    for tno = 1:length(gene_targets)     % Note: a gene's targets are
                                         % guaranteed to be non-overlapping,
                                         % after the analysis in condense_targets.m

      % match to start/end coordinates

      t = gene_targets(tno);
      ts = target.start(t);
      te = target.end(t);
      tlen = te - ts + 1;

      tumor_dna = char(zeros(tlen,1));   % has to be char to match datfile format 
      normal_dna = char(zeros(tlen,1));

      pat_targ_regions = pat_chr_regions(find(region.end(pat_chr_regions) >= ts ...
                     & region.start(pat_chr_regions) <= te));

      for rno = 1:length(pat_targ_regions)   % for each overlapping region (if any)

        any_regions_matched = true;
        r = pat_targ_regions(rno);

        % retrieve coverage from datfile

        rs = region.start(r);
        re = region.end(r);
        rlen = re - rs + 1;

        fno = region.fno(r);
        start_fpos = region.fpos(r);
        end_fpos = start_fpos + rlen - 1;

        % store coverage count for this region

        s = max(rs,ts);
        e = min(re,te);
 
        sidx = s-ts+1;
        eidx = e-ts+1;
        sidx2 = s+start_fpos-rs+1;
        eidx2 = e+start_fpos-rs+1;
        if region.is_tumor(r)
            tumor_dna([sidx:eidx]) = max(tumor_dna([sidx:eidx]), datfile{fno}([sidx2:eidx2]));            
        else
            normal_dna([sidx:eidx]) = max(normal_dna([sidx:eidx]), datfile{fno}([sidx2:eidx2]));
        end

      end   % next report region

      % finished processing this target

      cov = normal_dna & tumor_dna;                        % covered at least once in tumor + normal?
      seq = genome_region(gene_chr, ts-1, te+1, P.build);  % retrieve genomic sequence with +-1bp margin
      seq = upper(seq);                                    % make sure all uppercase

      % if target is on (-) strand, take reverse-complement
      
      if strcmp(target.strand{t}, '-')
          cov = cov(end:-1:1);
          seq = my_seqrcomplement(seq);    % function is in "Bioinformatics Toolbox"
      end

      % now count bases by category, adding to running total for this gene

      for i = 1:tlen
        if cov(i)
           bp = i+1;       % index into 'seq' must be incremented by 1 because of +-1bp margin
           if seq(bp) == 'A'
               category = 1;                        % A
           elseif seq(bp) == 'T'
               category = 2;                        % T
           elseif seq(bp) == 'C'
               if seq(bp+1) == 'G'
                    category = 3;                   % C in CpG
               elseif seq(bp-1) == 'T'
                    category = 4;                   % C in TpC but not TpCpG
               else
                    category = 5;                   % other C
               end
           elseif seq(bp) == 'G'
               if seq(bp-1) == 'C'
                    category = 6;                   % G in CpG
               elseif seq(bp+1) == 'A'
                    category = 7;                   % G in GpA but not CpGpA
               else
                    category = 8;                   % other G
               end
           else
               category = 9;                        % "N"?
           end
           cov_by_category(category) = cov_by_category(category) + 1;
        end
      end

    end   % next target in this gene

    % finished processing this gene:
    % output summary for this patient+gene

    if any_regions_matched
      fprintf(fout, '%s\t%s', patients{pno}, genes{gno});  
      for i=1:length(category_name)-1
        fprintf(fout, '\t%d', cov_by_category(i));
      end
      fprintf(fout, '\n');
    end

  end   % next gene

end   % next patient

fclose(fout);

